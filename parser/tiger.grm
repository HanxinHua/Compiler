structure A = Absyn
struct

end
%%
%term
    EOF
  | ID of string
  | INT of int | STRING of string
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK
  | LBRACE | RBRACE | DOT
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE | UMINUS
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF
  | BREAK | NIL
  | FUNCTION | VAR | TYPE
  | ERROR

%nonterm
		exp | program | lvalue | expseq | explist | field | declarationlist
	| declaration | typedeclaration	| variabledeclaration | functiondeclaration
	| type | typefield | typefields

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword
WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE DO OF NIL

%prefer THEN ELSE LPAREN

%right ID
%right OF
%right THEN
%right DO
%right ELSE
%right ASSIGN
%left AND OR
%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left DIVIDE TIMES
%right LBRACE LBRACK LPAREN
%left UMINUS

%change    EQ -> ASSIGN | ASSIGN -> EQ
		|  SEMICOLON ELSE -> ELSE |  ->IN INT END

%%

program	: exp				()



exp:   STRING                             (A.StringExp(STRING,STRINGleft))
	|  INT                                (A.IntExp(INT))
	|  NIL                                (A.NilExp))
	|  lvalue                             (if isSome (look(table, A.symbol lvalue)) then valOf look(table, A.symbol lvalue) else raise ERROR )
	|  MINUS exp  %prec UMINUS            (A.OpExp{left = 0   , oper = A.MinusOp,  right = exp,                 pos = MINUSleft})
	|  exp PLUS exp                       (A.OpExp{left = exp1, oper = A.PlusOp,   right = exp2,                pos = PLUSleft})
	|  exp MINUS exp                      (A.OpExp{left = exp1, oper = A.MinusOp,  right = exp2,                pos = MINUSleft})
	|  exp TIMES exp                      (A.OpExp{left = exp1, oper = A.TimesOp,  right = exp2,                pos = TIMESleft})
	|  exp DIVIDE exp                     (A.OpExp{left = exp1, oper = A.DivideOp, right = exp2,                pos = DIVIDEleft})
	|  exp AND exp                        (A.IfExp{test = exp1, then' = exp2,      else' = SOME 0,              pos = ANDleft})
	|  exp OR exp                         (A.IfExp{test = exp1, then' = 1,         else' = SOME exp2,           pos = ORleft})
	|  exp EQ exp                         (A.OpExp{left = exp1, oper = A.EqOp,     right = exp2,                pos = EQleft})
	|  exp NEQ exp                        (A.OpExp{left = exp1, oper = A.NeqOp,    right = exp2,                pos = NEQleft})
	|  exp LT exp                         (A.OpExp{left = exp1, oper = A.LtOp,     right = exp2,                pos = LTleft})
	|  exp LE exp                         (A.OpExp{left = exp1, oper = A.LeOp,     right = exp2,                pos = Leleft})
	|  exp GT exp                         (A.OpExp{left = exp1, oper = A.GtOp,     right = exp2,                pos = GTleft})
	|  exp GE exp                         (A.OpExp{left = exp1, oper = A.GEOp,     right = exp2,                pos = Geleft})
	|  lvalue ASSIGN exp                  (A.AssignExp{var = lvalue, exp = exp,                                 pos = ASSIGNleft})
	|  ID LPAREN explist RPAREN           (A.CallExp{func = A.symbol ID,      args = explist,              pos = IDleft})
	|  LPAREN expseq RPAREN               (A.SeqExp(expseq::[]))
<<<<<<< HEAD
	|  ID LBRACE field RBRACE             (A.RecordExp{fields = field, typ = Symbol.symbol ID,                  pos=IDleft})
	|  (A.ArrayExp{typ = Symbol.symbol ID, size = exp1, init = exp2,         pos = IDleft})
=======
	|  ID LBRACE field RBRACE             (A.RecordExp{fields = field , typ = A.symbol ID,                 pos=IDleft})
	|  ID LBRACK exp RBRACK OF exp        (A.ArrayExp{typ = A.symbol ID, size = exp1, init = exp2,         pos = IDleft})
>>>>>>> 5769c65479bf6e9d03a031aa0edddeebd3b9a431
	|  IF exp THEN exp                    (A.IfExp{test = exp1, then' = exp2,      else' = NONE,                pos = IFleft})
	|  IF exp THEN exp ELSE exp           (A.IfExp{test = exp1, then' = exp2,      else' = SOME exp3,           pos = IFleft})
	|  WHILE exp DO exp                   (A.WhileExp{test = exp1,  body = exp2,                                pos = WHILEleft})
	|  FOR ID ASSIGN exp TO exp DO exp    (A.ForExp{var = A.symbol ID, escape = ref true,
																			 lo = exp1, hi = exp2, body = exp3, pos = FORleft})
	|  BREAK                              (A.BreakExp(BREAKleft))
	|  LET declarationlist IN expseq END  (A.LetExp{decs = declarationlist, body = expseq,                      pos = LETleft})
	|  LPAREN ERROR RPAREN                (ERROR)

lvalue: ID                     (A.symbol(ID))
	   |lvalue DOT ID            (A.FieldVar{lvalue, A.symbol(ID), lvalueleft} )
	   |lvalue LBRACK exp RBRACK (A.SubscriptVar{lvalue, A.symbol(ID), lvalueleft})


expseq:   exp                 (exp :: nil)
	  | expseq SEMICOLON exp    (exp :: expseq)
		| ERROR  SEMICOLON exp    (exp :: ERROR)


explist:  exp           (exp :: nil)
		| explist COMMA exp (exp :: explist)
		| ERROR   COMMA exp (exp :: ERROR)

declarationlist: declaration           (declaration :: nil)
				 | declarationlist declaration (declaration :: declarationlist)

declaration: typedeclaration  ()
			| variabledeclaration   ()
			| functiondeclaration   ()

variabledeclaration: VAR ID ASSIGN exp (A.VarDec{name=A.symbol(ID), escape=ref false,
                                        type=Option.NONE, init=exp, pos=VARleft})
					 |VAR ID COLON ID ASSIGN exp (A.VarDec{name=A.symbol(ID), escape=ref false,
                                        type=Option.SOME((A.symbol(ID), IDleft)), init=exp, pos=VARleft})

functiondeclaration: FUNCTION ID LPAREN typefields RPAREN EQ exp (A.fundec{name = A.symbol ID, params = typefields,
															result: NONE,
															body = exp,
															pos = FUNCTIONleft})
					 |FUNCTION ID LPAREN typefields RPAREN COLON ID EQ exp (A.fundec{name = A.symbol ID1, params = typefields,
															result = SOME(A.symbol ID2, ID2left),
															body = exp,
															pos = FUNCTIONleft})

field: ID EQ exp             ((A.symbol(ID), exp, IDleft) :: [])
	   | field COMMA ID EQ exp ((A.symbol(ID), exp, IDleft) :: field)

typedeclaration: TYPE ID EQ ty (A.TypeDec{name=A.symbol(ID), ty=A.ty(ty), pos=IDleft})

ty: ID                          (A.symbol(ID))
    | LBRACE typefields RBRACE  (A.RecordTy(typefields))
    | LBRACE RBRACE             (A.RecordTy([]))
    | ARRAY OF ID               (A.ArrayTy{name=A.symbol(ID), pos=ARRAYleft})

typefields: typefield                   (typefield :: nil)
           | typefields COMMA typefield (typefields :: typefield)

typefield: ID COLON ID (A.field{name = A.symbol ID1, escape = ref true, typ = A.symbol ID2, pos = ID1left})
